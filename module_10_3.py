''''''
'''
Домашнее задание по теме "Блокировки и обработка ошибок"
Если вы решали старую версию задачи, проверка будет производиться по ней.
Ссылка на старую версию тут.
Цель: освоить блокировки потоков, используя объекты класса Lock и его методы.

Задача "Банковские операции":
Необходимо создать класс Bank со следующими свойствами:

Атрибуты объекта:
balance - баланс банка (int)
lock - объект класса Lock для блокировки потоков.

Методы объекта:
Метод deposit:
Будет совершать 100 транзакций пополнения средств.
Пополнение - это увеличение баланса на случайное целое число от 50 до 500.
Если баланс больше или равен 500 и замок lock заблокирован - lock.locked(), то разблокировать его методом release.
После увеличения баланса должна выводится строка "Пополнение: <случайное число>. Баланс: <текущий баланс>".
Также после всех операций поставьте ожидание в 0.001 секунды, тем самым имитируя скорость выполнения пополнения.
Метод take:
Будет совершать 100 транзакций снятия.
Снятие - это уменьшение баланса на случайное целое число от 50 до 500.
В начале должно выводится сообщение "Запрос на <случайное число>".
Далее производится проверка: если случайное число меньше или равно текущему балансу, то произвести снятие, 
уменьшив balance на соответствующее число и вывести на экран "Снятие: <случайное число>. Баланс: <текущий баланс>".
Если случайное число оказалось больше баланса, то вывести строку "Запрос отклонён, недостаточно средств" 
и заблокировать поток методом acquire.
Далее создайте объект класса Bank и создайте 2 потока для его методов deposit и take. Запустите эти потоки.
После конца работы потоков выведите строку: "Итоговый баланс: <баланс объекта Bank>".

Файл module_10_3.py загрузите на ваш GitHub репозиторий. В решении пришлите ссылку на него.
'''
import threading
# импорт библиотеки для работы с потоками
from random import randint
# импорт функции randint(вызов случайных чисел из диапазона от a до b randint(a,b)
# из библиотеки random
from time import sleep


# импорт функции sleep(задание паузы таймаута на сек sleep(сек)
# из библиотеки time

class Bank:
    '''
    Класс Банк
    '''

    def __init__(self):
        '''
        self.balance : int - баланс в банке
        self.transaction_with=100 количество транзакций пополнения
        self.transaction_repl = 100 количество транзакция снятия
        self.lock=threading.Lock блокировка потока из класса Lock
        self.sleep_time = 0.001 время таймаута
        self.rand_min = 50 минимальная сумма транзакции
        self.rand_max = 500 максимальная сумма транзакции        '''
        self.balance = 0
        self.transaction_with = 100
        self.transaction_repl = 100
        self.lock = threading.Lock()
        self.sleep_time = 0.001
        self.rand_min = 50
        self.rand_max = 500

    def deposit(self):
        # функция добавления к счёту в банке
        for tr in range(self.transaction_with):
            # проходим циклом от 0 до 100 количества транзакций для поступления средств
            if self.balance >= self.rand_max and self.lock.locked():
                # если баланс больше или равен сумме транзакции
                # и доступ к данным класса Bank заблокирован
                self.lock.release()
                # разблокируем доступ к данным класса Bank
            sum_with = randint(self.rand_min, self.rand_max)
            # сумма транзакции выбирается из случайных чисел
            self.balance += sum_with
            # к балансу в банке прибавить сумму транзакции
            print(f'Пополнение: {sum_with}. Баланс: {self.balance}')
            sleep(self.sleep_time)
            # таймаут
        else:
            # если число транзакций превышено и цикл закончился
            print(f'Лимит транзакций для пополнения баланса закончен!')
            # выводим сообщение

    def take(self):
        # функция расхода к счёту в банке
        print(threading.current_thread())
        for tr in range(100):
            # проходим циклом от 0 до 100 количества транзакций для расхода средств
            sum_repl = randint(self.rand_min, self.rand_max)
            # сумма транзакции выбирается из случайных чисел
            print(f'Запрос на {sum_repl}')
            # Сообщение о сумме транзакции выбирается из случайных чисел
            if sum_repl <= self.balance:
                # если баланс больше или равен сумме транзакции
                self.balance -= sum_repl
                # из баланса в банке отнять сумму транзакции
                print(f'Снятие {sum_repl}. Баланс {self.balance}')
            else:
                # иначе
                print('Запрос отклонён, недостаточно средств')
                self.lock.acquire()
                # блокируем доступ к данным класса Bank
                sleep(self.sleep_time)
                # таймаут
        else:
            # если число транзакций превышено и цикл закончился
            print(f'Лимит транзакций для снятия с баланса закончен!')
            # выводим сообщение


bk = Bank()
# присваиваем переменной bk атрибут экземпляра Bank()
th1 = threading.Thread(target=Bank.deposit, args=(bk,))
# создаем конструктором поток th1 и передаем в Класс Thread модуля threading
# функцию Bank.deposit с атрибут экземпляра Bank()
th2 = threading.Thread(target=Bank.take, args=(bk,))
# создаем конструктором поток th1 и передаем в Класс Thread модуля threading
# функцию Bank.take с атрибут экземпляра Bank()

th1.start()
# запуск потока th1 через Thread.run()
th2.start()
# запуск потока th2 через Thread.run()
th1.join()
# приостановка потока
th2.join()
# приостановка потока
print(f'Итоговый баланс: {bk.balance}')
